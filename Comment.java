/**
*    @cubohan
*    circa 2015
*
*    java-commenting-tool (terminal)
*    Makes commenting in universal format easier. It handles typing the "*" and give four spaces at the start of each line.
*    Accepts arguments from terminal to give an appropriate GUI(via termnal prompt) response. 
*    Supports signature saving and file commenting.
*    
*    (This very comment is generated by this tool via terminal inputs. Notice the customizable signature at the top.)
*    
*    OPTIONS:
*    COMPILE the file and EXECUTE it via cmd/terminal and enter "--help", pressing return. 
*/

import java.io.*;

class Settings{
	public static String initial = "/**\n";
	public static String prepend = "*    ";
	public static String append = "*/";
	public static String signature = "@cubohan\n*    circa2015";
}

public class Comment{
	public static void main(String args[]){
		GUIResponse gur = new GUIResponse();
		gur.initiateResponse();

	}
}


/**
*
*	User Interface Layer
*
*/

class GUIResponse{

	private InputPrompt ip;
	private Interpreter ir;

	private String comment;
	private String filepath = "/home/cubohan/workspace/script/comment/aaa";

	static  String help = "\n*help:\n--help\n\tstop commentary (restart) --stop\n\taccess settings --set\n\tchange file --file\n\tchange user --user\n\tdelete/clear/redo last comment --clear\n\tprint last comment --print\n\tsave comment to target file --done\n\texit press(CTRL+Z)\n";

	static  String stop = "\nCurrent commentary has been stopped.";
	static  String resume = "\nLast commentary has been kickstarted.";

	static  String settings = "\nRequest to review settings has been acknowledged.";

	static  String file = "\nZeroing in on target file. Engaging at multiple fronts.";

	static  String user = "\nCompelling subroutine to address user...";
	static  String clear = "\nCurrent Commentary has been scratched."; 

	static String commentPreview = "\nComment assimilated so far...\n\n";
	static String dumping = "\nEnforcing AD-HOC deletion. Restarting commenting machinations.\n";

	public GUIResponse(){
		ip = new InputPrompt();
		ir = new Interpreter(null);

	}
	
	/*
	*	Greet User, prompt settings change, file address, 
	*/
	public void initiateResponse(){
		String init = "\nInitializing Commentor V0.1.";
		print(init);

		greetUser();
		//respondSettings();
		//respondFile();
		initiateCommentary();

		farewell();

	}

	void respondHelp(){
		print(help);
	}

	boolean respondStop(){
		print(stop);
		return false;
	}

	boolean respondResume(){
		print(resume);
		return true;
	}

	void respondSettings(){
		print(settings);
		//initial
		//prepend
		//signature
		print("\nCurrent Settings:\n\t-initial-text: " + Settings.initial + "\t-prepended-text: " + Settings.prepend + "\n\t-signature: " + Settings.signature);

		print("\nDo you want to change settings?");
		if(!ask(false)){
		print("\nAcknowledged command to skip editing settings.");
			return;
		}

		print("\nDo you want to change the initial text?");
		if(ask(true)){
			Settings.initial = ip.getInput();
		}
		print("\nDo you want to change the prepended text?");
		if(ask(true)){
			Settings.prepend = ip.getInput();
		}
		print("\nDo you want to change the signature?");
		if(ask(true)){
			Settings.signature = ip.getInput();
		}

		print("\nYou have reviewed all settings. Shutting down setting's editor.");

		//display settings
	}

	void respondFile(){
		print(file);
		print("\nThe current parameter value of 'filepath' is " + filepath + "\n");
		print("\nDo you want to set the file path?");
		if(ask(true)){
			filepath = ip.getInput();
			print("\nFilePath is confirmed. Roger that.\n");
		}

		else
			print("Forcing system to default on filepath.");		

	}

	void greetUser(){
		print("\nWelcome, " + Settings.signature + ".");
	}

	void respondPrint(){

	}

	void farewell(){
		print("\nBye " + Settings.signature + ".\n");
	}

	void respondUser(){
		print(user);
		print(Settings.signature + "\n");
	}

	void dump(){
		print(dumping);
		comment = "";
	}

	void vocal(){
		print(commentPreview);
		print(comment);
	}
	void setFilePath(String st){
		filepath = new String (st);
	}
	void save(){
		comment += Settings.append;
		vocal();
		try {

			File file = new File(filepath);	
			// if file doesnt exists, then create it
			if (!file.exists()) {
				file.createNewFile();
			}

			FileWriter fw = new FileWriter(file.getAbsoluteFile());
			BufferedWriter bw = new BufferedWriter(fw);
			bw.write(comment);
			bw.close();

			System.out.println("\nDone.\n");

		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	void edit(String st){
		comment = new String(st);
	}
	
	void initiateCommentary(){
		//get input
		//interpret
		//act
		//loop back
		print("\nCommentary has been initialized. Everything will be recorded.\n");
		edit(Settings.initial + Settings.prepend + Settings.signature + "\n" + Settings.prepend +"\n");
		boolean cont = true;
		String current = null;
		boolean add = true;
		while (cont){
			current = ip.getInput();
			ir.set(current);
			add = ir.interpretOpt(this);

			if(add){
				comment += (Settings.prepend + current + "\n");
			}

		}
	}

	static void print(String st){
		System.out.println(st);
	}

	boolean ask(boolean prom){
		if(ir.interpretChoice(ir.set(ip.getInput()))){
			if(prom)
				print("\nWhat will it be?");
			return true;
		}
		else{
			return false;
		}
	}
	

};

//Input Stream READER:

class InputPrompt{
	
	private BufferedReader br;
	


	public InputPrompt(){
		br = new BufferedReader(new InputStreamReader(System.in));
	}

	public static void prompt(){
		System.out.println("\n@cubohan input...");
	}

	public String getInput(){
		
		//prompt();

		String input = null;
		while(input == null){
			try{
				input = br.readLine();
			}
			catch(IOException io){
				io.printStackTrace();
				System.out.println("Please enter valid input.");
			}
		}
		//assessString(input);

		return input;
	}

	public static void assessString(String test){
		int attr[] = new int[10];

		//test 1
		attr[0] = test.length();

		for(int i=0; i<1; i++){
			System.out.println(attr[i]);
		}
	}

};



/**
*	Business Logic Layer
*	
*	class Interpreter
*	
*	terminal interrupts:callsign(--)
*		help
*		stop commentary (restart)
*		resume commentary
*		access settings
*		change file
*		jump
*		change user
*		delete/clear/redo last comment
*		print last comment
*		end comment
*		exit
*/
//LP, regex, 
class Interpreter{

	private String str;
	private static String  qualifier = "--" ;
	public Interpreter(String  st){
		str = st;
	}

	public String set(String st){
		str = st;
		return str;
	}

	public boolean interpretOpt(GUIResponse gr){
		if (str.startsWith(qualifier)){
			String cmd = str.substring(qualifier.length(), str.length());
				if (cmd.equals("help")){
					gr.respondHelp();
				}
				else if (cmd.equals("done")){
					gr.save();
				}
				else if (cmd.equals("resume")){
				}
				else if (cmd.equals("set")){
					gr.respondSettings();
					
				}
				else if (cmd.equals("file")){
					gr.respondFile();

				}
				else if (cmd.equals("user")){

					gr.respondUser();
					
				}
				else if (cmd.equals("clear")){
					gr.dump();
					gr.edit(Settings.initial + Settings.prepend + Settings.signature + "\n" + Settings.prepend +"\n");
					
				}
				else if (cmd.equals("print")){
					gr.vocal();
					
				}
				else if (cmd.equals("exit")){

					
				}
				return false;		
			

		}

		return true;
	}

	public boolean interpretChoice(String str){
		if(str.equals("y") || str.equals("yes")){
			return true;
		}
		else
			return false;
	}


};

class User{

};
